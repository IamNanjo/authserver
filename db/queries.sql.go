// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
)

const addMigration = `-- name: AddMigration :exec
INSERT INTO MIGRATION (id)
VALUES (?)
`

func (q *Queries) AddMigration(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, addMigration, id)
	return err
}

const createApp = `-- name: CreateApp :one
INSERT INTO App (
	id,
	name,
	description
) VALUES (hex(randomblob(6)), ?, ?) RETURNING id, name, description
`

type CreateAppParams struct {
	Name        string  `db:"name" json:"name"`
	Description *string `db:"description" json:"description"`
}

func (q *Queries) CreateApp(ctx context.Context, arg CreateAppParams) (App, error) {
	row := q.db.QueryRowContext(ctx, createApp, arg.Name, arg.Description)
	var i App
	err := row.Scan(&i.Id, &i.Name, &i.Description)
	return i, err
}

const createDomain = `-- name: CreateDomain :one
INSERT INTO Domain (
	name,
	app
) VALUES (?, ?) RETURNING name, app
`

type CreateDomainParams struct {
	Name string `db:"name" json:"name"`
	App  string `db:"app" json:"app"`
}

func (q *Queries) CreateDomain(ctx context.Context, arg CreateDomainParams) (Domain, error) {
	row := q.db.QueryRowContext(ctx, createDomain, arg.Name, arg.App)
	var i Domain
	err := row.Scan(&i.Name, &i.App)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO User (
	id,
	name,
	email,
	password
) VALUES (hex(randomblob(6)), ?, ?, ?)
RETURNING id, name, email, password, role
`

type CreateUserParams struct {
	Name     string  `db:"name" json:"name"`
	Email    *string `db:"email" json:"email"`
	Password *string `db:"password" json:"password"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Name, arg.Email, arg.Password)
	var i User
	err := row.Scan(
		&i.Id,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.Role,
	)
	return i, err
}

const getApp = `-- name: GetApp :one
SELECT id, name, description FROM App
WHERE id = ?
`

func (q *Queries) GetApp(ctx context.Context, id string) (App, error) {
	row := q.db.QueryRowContext(ctx, getApp, id)
	var i App
	err := row.Scan(&i.Id, &i.Name, &i.Description)
	return i, err
}

const getAppDomains = `-- name: GetAppDomains :many
SELECT name, app FROM Domain
WHERE app = ?
`

func (q *Queries) GetAppDomains(ctx context.Context, app string) ([]Domain, error) {
	rows, err := q.db.QueryContext(ctx, getAppDomains, app)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Domain
	for rows.Next() {
		var i Domain
		if err := rows.Scan(&i.Name, &i.App); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppManagers = `-- name: GetAppManagers :many
SELECT
	u.id id,
	u.name name,
	u.password password,
	u.email email,
	u.role role
FROM User u
INNER JOIN AppUser au ON
	u.id = au.user AND
	au.role = 2
WHERE au.app = ?
`

type GetAppManagersRow struct {
	Id       string  `db:"id" json:"id"`
	Name     string  `db:"name" json:"name"`
	Password *string `db:"password" json:"password"`
	Email    *string `db:"email" json:"email"`
	Role     int64   `db:"role" json:"role"`
}

func (q *Queries) GetAppManagers(ctx context.Context, app *string) ([]GetAppManagersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAppManagers, app)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAppManagersRow
	for rows.Next() {
		var i GetAppManagersRow
		if err := rows.Scan(
			&i.Id,
			&i.Name,
			&i.Password,
			&i.Email,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppUsers = `-- name: GetAppUsers :many
SELECT
	id,
	name,
	password,
	email, 
	u.role role,
	au.role app_role
FROM User u
INNER JOIN AppUser au
	ON u.id = au.user
WHERE au.app = ?
`

type GetAppUsersRow struct {
	Id       string  `db:"id" json:"id"`
	Name     string  `db:"name" json:"name"`
	Password *string `db:"password" json:"password"`
	Email    *string `db:"email" json:"email"`
	Role     int64   `db:"role" json:"role"`
	AppRole  int64   `db:"app_role" json:"appRole"`
}

func (q *Queries) GetAppUsers(ctx context.Context, app *string) ([]GetAppUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAppUsers, app)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAppUsersRow
	for rows.Next() {
		var i GetAppUsersRow
		if err := rows.Scan(
			&i.Id,
			&i.Name,
			&i.Password,
			&i.Email,
			&i.Role,
			&i.AppRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApps = `-- name: GetApps :many
SELECT id, name, description FROM App
`

func (q *Queries) GetApps(ctx context.Context) ([]App, error) {
	rows, err := q.db.QueryContext(ctx, getApps)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []App
	for rows.Next() {
		var i App
		if err := rows.Scan(&i.Id, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestMigration = `-- name: GetLatestMigration :one
SELECT id From Migration
ORDER BY id DESC
LIMIT 1
`

func (q *Queries) GetLatestMigration(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getLatestMigration)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getSessionById = `-- name: GetSessionById :one
SELECT id, user, device, last_used, expires_at, token FROM Session
WHERE id = ?
`

func (q *Queries) GetSessionById(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSessionById, id)
	var i Session
	err := row.Scan(
		&i.Id,
		&i.User,
		&i.Device,
		&i.LastUsed,
		&i.ExpiresAt,
		&i.Token,
	)
	return i, err
}

const getSessions = `-- name: GetSessions :many
SELECT id, user, device, last_used, expires_at, token FROM Session
WHERE user = ?
`

func (q *Queries) GetSessions(ctx context.Context, user string) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, getSessions, user)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.Id,
			&i.User,
			&i.Device,
			&i.LastUsed,
			&i.ExpiresAt,
			&i.Token,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, password, role FROM User
WHERE email = ?
`

func (q *Queries) GetUserByEmail(ctx context.Context, email *string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.Id,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.Role,
	)
	return i, err
}

const getUserByEmailOrUsername = `-- name: GetUserByEmailOrUsername :one
SELECT id, name, email, password, role FROM User
WHERE
	email = ?1 OR
	name = ?1
LIMIT 1
`

func (q *Queries) GetUserByEmailOrUsername(ctx context.Context, emailorusername *string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmailOrUsername, emailorusername)
	var i User
	err := row.Scan(
		&i.Id,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.Role,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, name, email, password, role FROM User
WHERE id = ?
`

func (q *Queries) GetUserById(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.Id,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.Role,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, name, email, password, role FROM User
WHERE name = ?
`

func (q *Queries) GetUserByUsername(ctx context.Context, name string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, name)
	var i User
	err := row.Scan(
		&i.Id,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.Role,
	)
	return i, err
}
